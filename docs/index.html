<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>NASM Assembly Tutorials - asmtutor.com</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <link href="./assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="./assets/stylesheet.css" rel="stylesheet">
    <link href="./assets/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">

	<script src="./assets/syntax-highlighter/scripts/shCore.js"></script>
	<script src="./assets/syntax-highlighter/scripts/shBrushAsm.js"></script>
	<link href="./assets/syntax-highlighter/styles/shCoreDefault.css" rel="stylesheet">

	<script type="text/javascript">SyntaxHighlighter.all();</script>
    
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">
    <link rel="shortcut icon" href="../assets/ico/favicon.png">
</head>

<body>

    <div class="navbar navbar-inverse navbar-fixed-top">
        <div class="navbar-inner">
            <div class="container-fluid">
                <span class="brand">NASM Assembly Tutorials - asmtutor.com</span>
                <div class="nav-collapse collapse">
                    <p class="navbar-text pull-right">
                        <a class="navbar-link" href="#top">Top</a>
                    </p>
                </div>
            </div>
        </div>
    </div>    

    <div class="container-fluid">
        <div class="row-fluid">
            
            <div class="span3">
                <div class="well sidebar-nav">
                    <ul class="nav nav-list">
                        <li class="nav-header">Lessons</li>
                        <li><a href="#lesson1">Lesson 1 <span>Hello, world!</span></a></li>
                        <li><a href="#lesson2">Lesson 2 <span>Proper program exit</span></a></li>
                        <li><a href="#lesson3">Lesson 3 <span>Calculate string length</span></a></li>
                        <li><a href="#lesson4">Lesson 4 <span>Subroutines</span></a></li>
                        <li><a href="#lesson5">Lesson 5 <span>External include files</span></a></li>
                        <li><a href="#lesson6">Lesson 6 <span>NULL terminating bytes</span></a></li>
                    </ul>
                </div>
            </div>
            
            <div class="span9 lessons">
                
                <div class="hero-unit">
                    <h2>Learn Assembly</h2>
                    <p>This project was put together to teach myself NASM 64bit assembly language on linux. The tutorials are designed to flow on from each other adding functionality at each stage.</p>
                    <p><a href="https://github.com/DGivney/assemblytutorials" class="btn btn-primary btn" target="_blank">Github Project &raquo;</a></p>
                </div>
                  
                <div class="row-fluid">
                    <div class="span4">
                        <h2>Lesson 1</h2>
                        <h5>The obligatory 'Hello, world!'</h5>
                        <p>Introduction to the Linux System Call Table.  In this lesson we use software interrupts to request system functions from the kernel in order to print out 'Hello World!' to the console.</p>
                        <p><a class="btn" href="#lesson1">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 2</h2>
                        <h5>Proper program exit</h5>
                        <p>A very brief lesson about memory addresses, sequential code execution and how to properly terminate a program without errors.</p>
                        <p><a class="btn" href="#lesson2">View details &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 3</h2>
                        <h5>Calculate string length</h5>
                        <p>What if we wanted to output something that we don't know the length of? Like user input? Learn about loops, labels and pointer arithmic.</p>
                        <p><a class="btn" href="#lesson3">View details &raquo;</a></p>
                    </div>
                </div>

                <div class="row-fluid">
                    <div class="span4">
                        <h2>Lesson 4</h2>
                        <h5>Subroutines</h5>
                        <p>Introduction to the stack and how to write clean, reusable code in assembly.</p>
                        <p><a class="btn" href="#lesson4">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 5</h2>
                        <h5>External include files</h5>
                        <p>To further simplify our code we can move our subroutines into an external include file.</p>
                        <p><a class="btn" href="#lesson5">View details &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 6</h2>
                        <h5>NULL terminating bytes</h5>
                        <p>A quick lesson on how memory is handled. This lesson also fixes the duplication bug we added in lesson 4.</p>
                        <p><a class="btn" href="#lesson6">View details &raquo;</a></p>
                    </div>
                </div>
                                
                <hr>
                
                <div class="row-fluid" id="lesson1">
                    <article class="span12">
                        <header>
                            <h2>Lesson 1</h2>
                            <h4>Hello, world!</h4>
                        </header>

                            <h5>First, some background</h5>

                            <p>Assembly language is bare-bones. The only interface a programmer has above the actual hardware is the kernel itself. In order to build useful programs in assembly we need to use the linux system calls provided by the kernel. These system calls are a library built into the operating system to provide functions such as reading input from a keyboard and writing output to the screen.</p>

                            <p>When you invoke a system call the kernel will immediately suspend execution of your program.  It will then contact the necessary drivers needed to perform the task you requested on the hardware and then return control back to your program.</p>

                            <p>
                                <span class="label label-info">Note:</span>
                                Drivers are called <i>drivers</i> because the kernel literally uses them to drive the hardware.
                            </p>
                        
                            <p>We can accomplish this all in assembly by loading EAX with the function number (operation code OPCODE) we want to execute and filling the remaining registers with the arguments we want to pass to the system call. A software interrupt is requested with the INT instruction and the kernel takes over and calls the function from the library with our arguments. Simple.</p>

                            <p>For example requesting an interrupt when EAX=1 will call sys_exit() and requesting an interrupt when EAX=4 will call sys_write() instead. EBX, ECX & EDX will be passed as arguments if the function requires them. <a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html" target="_blank">Click here to view an example of a Linux System Call Table and its corresponding OPCODES.</a></p>

                            <h5>Writing our program</h5>

                            <p>Firstly we create a variable 'msg' in our .data section and assign it the string we want to output in this case 'Hello, world!'. In our .text section we tell the kernel where to begin execution by providing it with a global label _start: to denote the programs entry point.</p>

                            <p>We will be using the system call sys_write to output our message to the console window.  This function is assigned OPCODE 4 in the Linux System Call Table.  The function also takes 3 arguments which are sequentially loaded into EDX, ECX and EBX before requesting a software interrupt which will perform the task.</p>

                            <p>The arguments passed are as follows:
                                <ul>
                                    <li> EDX will be loaded with the length (in bytes) of the our string.</li>
                                    <li> ECX will be loaded with the address of our variable created in the .data section.</li>
                                    <li> EBX will be loaded with the file we want to write to â€“ in this case STDOUT.</li>
                                </ul>
                                The datatype and meaning of the arguments passed can be found in the function's definition.
                            </p>

                            <p>We compile, link and run the program using the commands below.</p>

                        <div class="snippet">
                            <span class="filename">helloworld.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program - asmtutor.com
                            ; Compile with: nasm -f elf helloworld.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
                            ; Run with: ./helloworld

                            SECTION .data
                            msg     db      'Hello World!', 0Ah     ; assign msg variable with your message string

                            SECTION .text
                            global  _start

                            _start: 

                                mov     edx, 13     ; number of bytes to write - one for each letter plus 0Ah (line feed character)
                                mov     ecx, msg    ; move the memory address of our message string into ecx
                                mov     ebx, 1      ; write to the STDOUT file
                                mov     eax, 4      ; invoke SYS_WRITE (kernel opcode 4)
                                int     80h
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld.o -o helloworld</span>
                                    <span>~$ ./helloworld</span>
                                    <span>Hello World!</span>
                                    <span>Segmentation fault</span>
                                </div>
                            </div>
                        </div>

                        <p>
                            <span class="label label-important">Error:</span>
                            Segmentation fault
                        </p>
                        
                    </article>
                </div>

                <hr>

                <div class="row-fluid" id="lesson2">
                    <article class="span12">
                        <header>
                            <h2>Lesson 2</h2>
                            <h4>Proper program exit</h4>
                        </header>

                        <h5>Some more background</h5>

                        <p>After successfully learning now to execute a system call in Lesson 1 we now need to learn about one of the most important system calls in the kernel, sys_exit.</p>

                        <p>Notice how after our 'Hello, world!' program ran we got a Segmentation fault? Well, computer programs can be thought of as a long strip of instructions that are loaded into memory and divided up into sections (or segments). This general pool of memory is shared between all programs and can be used to store variables, instructions, other programs or anything really. Each segment is given an address so that information stored in that section can be found later.</p>

                        <p>To execute a program that is loaded in memory, we use the global label _start: to tell the operating system where in memory our program can be found and executed.  Memory is then accessed sequentially following the program logic which determines the next address to be accessed. The kernel jumps to that address in memory and executes it.</p>

                        <p>It's important to tell the operating system exactly where it should begin execution and where it should stop. In Lesson 1 we didn't tell the kernel where to stop execution. So, after we called sys_write the program continued sequentially executing the next address in memory, which could have been anything. We don't know what the kernel tried to execute but it caused it to choke and terminate the process for us instead - leaving us the error message of 'Segmentation fault'.  Calling sys_exit at the end of all our programs will mean the kernel knows exactly when to terminate the process and return memory back to the general pool thus avoiding an error.</p>

                        <h5>Writing our program</h5>

                        <p>Sys_exit has a simple function definition.  In the Linux System Call Table it is allocated OPCODE 1 and is passed a single argument through EBX.</p>

                        <p>In order to execute this function all we need to do is:
                            <ul>
                                <li>Load EBX with 0 to pass zero to the function meaning 'zero errors'.</li>
                                <li>Load EAX with 1 to call sys_exit.</li>
                                <li>Then request an interrupt on libc using INT 80h.</li>
                            </ul>
                        </p>

                        <p>We then compile, link and run it again.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            Only new code added in each lesson will be commented.
                        </p>
                        
                        <div class="snippet">
                            <span class="filename">helloworld.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program - asmtutor.com
                            ; Compile with: nasm -f elf helloworld.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
                            ; Run with: ./helloworld

                            SECTION .data
                            msg     db      'Hello World!', 0Ah

                            SECTION .text
                            global  _start

                            _start: 

                                mov     edx, 13
                                mov     ecx, msg
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0      ; return 0 status on exit - 'No Errors'
                                mov     eax, 1      ; invoke SYS_EXIT (kernel opcode 1)
                                int     80h
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld.o -o helloworld</span>
                                    <span>~$ ./helloworld</span>
                                    <span>Hello World!</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson3">
                    <article class="span12">
                        <header>
                            <h2>Lesson 3</h2>
                            <h4>Calculate string length</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>Why do we need to calculate the length of a string?</p>

                        <p>Well sys_write requires that we pass it a pointer to the string we want to output in memory and the length in bytes we want to print out.  If we were to modify our message string we would have to update the length in bytes that we pass to sys_write as well, otherwise it will not print correctly. </p>

                        <p>You can see what I mean using the program in Lesson 2.  Modify the message string to say 'Hello, brave new world!' then compile, link and run the new program.  The output will be 'Hello, brave ' (the first 13 characters) because we are still only passing 13 bytes to sys_write as its length.  It will be particularly necessary when we want to print out user input.  As we won't know the length of the data when we compile our program, we will need a way to calculate the length at runtime in order to successfully print it out.</p>

                        <h5>Writing our program</h5>

                        <p>To calculate the length of the string we will use a technique called pointer arithmetic.  Two registers are initialised pointing to the same address in memory.  One register (in this case EAX) will be incremented forward one byte for each character in the output string until we reach the end of the string.  The original pointer will then be subtracted from EAX.  This is effectively like subtraction between two arrays and the result yields the number of elements between the two addresses. This result is then passed to sys_write replacing our hard coded count.</p>

                        <p>The CMP instruction compares the left hand side against the right hand side and sets a number of flags that are used for program flow.  The flag we're checking is the ZF or Zero Flag.  When the byte that EAX points to is equal to zero the ZF flag is set.  We then use the JZ instruction to jump, if the ZF flag is set, to the point in our program labeled 'finished'. This is to break out of the nextchar loop and continue executing the rest of the program.</p>
                                                
                        <div class="snippet">
                            <span class="filename">helloworld-len.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Calculating string length)
                            ; Compile with: nasm -f elf helloworld-len.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
                            ; Run with: ./helloworld-len

                            SECTION .data
                            msg     db      'Hello, brave new world!', 0AH ; we can modify this now without having to update anywhere else in the program

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     ebx, msg        ; move the address of our message string into EBX
                                mov     eax, ebx        ; move the address in EBX into EAX as well (Both now point to the same segment in memory)
                                
                            nextchar:
                                cmp     byte [eax], 0   ; compare the byte pointed to by EAX at this address against zero (Zero is an end of string delimiter)
                                jz      finished        ; jump (if the zero flagged has been set) to the point in the code labeled 'finished'
                                inc     eax             ; increment the address in EAX by one byte (if the zero flagged has NOT been set)
                                jmp     nextchar        ; jump to the point in the code labeled 'nextchar'
                                
                            finished:
                                sub     eax, ebx        ; subtract the address in EBX from the address in EAX
                                                        ; remember both registers started pointing to the same address (see line 15)
                                                        ; but EAX has been incremented one byte for each character in the message string
                                                        ; when you subtract one memory address from another of the same type
                                                        ; the result is number of segments between them - in this case the number of bytes
                                
                                mov     edx, eax        ; EAX now equals the number of bytes in our string
                                mov     ecx, msg        ; the rest of the code should be familiar now
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-len.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
                                    <span>~$ ./helloworld-len</span>
                                    <span>Hello, brave new world!</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>

                <hr>

                <div class="row-fluid" id="lesson4">
                    <article class="span12">
                        <header>
                            <h2>Lesson 4</h2>
                            <h4>Subroutines</h4>
                        </header>

                        <h5>Introduction to subroutines</h5>

                        <p>Subroutines are functions.  They are reusable pieces of code that can be called by your program to perform various repeatable tasks.  Subroutines are declared using labels just like we've used before (eg. _start:) however we don't use the JMP instruction to get to them - instead we use an new instruction CALL. We also don't use the JMP instruction to return to our program after we have run the function.  To return to our program from a subroutine we use the instruction RET instead.</p>

                        <h5>Why don't we JMP to subroutines?</h5>

                        <p>The great thing about writing a subroutine is that we can reuse it.  If we want to be able to use the subroutine from anywhere in the code we would have to write some logic to determine where in the code we had jumped from and where we should jump back to.  This would litter our code with unwanted labels.  If we use CALL and RET however, assembly handles this problem for us using something called the stack.</p>

                        <h5>Introduction to the stack</h5>

                        <p>The stack is a special type of memory.  It's the same type of memory that we've used before however it's special in how it is used by our program.  The stack is what is call <strong>Last In First Out</strong> memory (LIFO).  You can think of the stack like a stack of plates in your kitchen.  The last plate you put on the stack is also the first plate you will take off the stack next time you use a plate.</p>

                        <p>The stack in assembly is not storing plates though, its storing values.  You can store a lot of things on the stack such as variables, addresses or other programs.  We need to use the stack when we call subroutines to temporarily store values that will be restored later.</p>

                        <p>Any register that your function needs to use should have it's current value put on the stack for safe keeping using the PUSH instruction.  Then after the function has finished it's logic, these registers can have their original values restored using the POP instruction.  This means that any values in the registers will be the same before and after you've called your function.  If we take care of this in our subroutine we can call functions without worrying about what changes they're making to our registers.</p>

                        <p>The CALL and RET instructions also use the stack.  When you CALL a subroutine, the address you called it from in your program is pushed onto the stack.  This address is then popped off the stack by RET and the program jumps back to that place in your code.  This is why you should always JMP to labels but you should CALL functions.</p>
                                          
                        <div class="snippet">
                            <span class="filename">helloworld-len.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Subroutines)
                            ; Compile with: nasm -f elf helloworld-len.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
                            ; Run with: ./helloworld-len

                            SECTION .data
                            msg     db      'Hello, brave new world!', 0AH

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg        ; move the address of our message string into EAX
                                call    strlen          ; call our function to calculate the length of the string
                                
                                mov     edx, eax        ; our function leaves the result in EAX
                                mov     ecx, msg        ; this is all the same as before
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h
                                
                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h

                            strlen:                     ; this is our first function declaration
                                push    ebx             ; push the value in EBX onto the stack to preserve it while we use EBX in this function
                                mov     ebx, eax        ; move the address in EAX into EBX (Both point to the same segment in memory)
                                
                            nextchar:                   ; this is the same as lesson3
                                cmp     byte [eax], 0   
                                jz      finished        
                                inc     eax             
                                jmp     nextchar        
                                
                            finished:
                                sub     eax, ebx
                                pop     ebx             ; pop the value on the stack back into EBX
                                ret                     ; return to where the function was called
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-len.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
                                    <span>~$ ./helloworld-len</span>
                                    <span>Hello, brave new world!</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson5">
                    <article class="span12">
                        <header>
                            <h2>Lesson 5</h2>
                            <h4>External include files</h4>
                        </header>

                        <p>External include files allow us to move code from our program and put it into separate files. This technique is useful for writing clean, easy to maintain programs. Reusable bits of code can be written as subroutines and stored in separate files called libraries. When you need a piece of logic you can include the file in your program and use it as if they are part of the same file.</p>

                        <p>In this lesson we will move our string length calculating subroutine into an external file.  We fill also make our string printing logic and program exit logic a subroutine and we will move them into this external file.  Once it's completed our actual program will be clean and easier to read.</p>

                        <p>We can then declare another message variable and call our print function twice in order to demonstrate how we can reuse code.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            I won't be showing the code in functions.asm after this lesson unless it changes. It will just be included if needed.
                        </p>          
                  
                        <div class="snippet">
                            <span class="filename">functions.asm</span>
                            <pre class="brush: asm;">
                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:                     
                                push    ebx             
                                mov     ebx, eax        
                                
                            nextchar:                   
                                cmp     byte [eax], 0   
                                jz      finished        
                                inc     eax             
                                jmp     nextchar        
                                
                            finished:
                                sub     eax, ebx
                                pop     ebx             
                                ret                     


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    eax
                                call    slen
                                
                                mov     edx, eax
                                pop     eax
                                
                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h
                                ret


                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h
                                ret


                            </pre>
                        </div>
                        
                        <div class="snippet">
                            <span class="filename">helloworld-inc.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (External file include)
                            ; Compile with: nasm -f elf helloworld-inc.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
                            ; Run with: ./helloworld-inc

                            %include        'functions.asm'                             ; include our external file

                            SECTION .data
                            msg1    db      'Hello, brave new world!', 0AH              ; our first message string
                            msg2    db      'This is how we recycle in NASM.', 0AH      ; our second message string

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg1       ; move the address of our first message string into EAX
                                call    sprint          ; call our string printing function
                                
                                mov     eax, msg2       ; move the address of our second message string into EAX
                                call    sprint          ; call our string printing function
                                
                                call    quit            ; call our quit function
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-inc.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
                                    <span>~$ ./helloworld-inc</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                    <span>This is how we recycle in NASM.</span>
                                </div>
                            </div>
                        </div>

                        <p>
                            <span class="label label-important">Error:</span>
                            Our second message is outputted twice.  This is fixed in the next lesson.
                        </p>
                        
                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson5">
                    <article class="span12">
                        <header>
                            <h2>Lesson 6</h2>
                            <h4>NULL terminating bytes</h4>
                        </header>

                        <p>Ok so why did our second message print twice when we only called our sprint function on msg2 once?  Well actually it did only print once.  You can see what I mean if you comment out our second call to sprint.  The output will be both of our message strings.</p>

                        <p>But how is this possible?</p>

                        <p>What is happening is we weren't properly terminating our strings.  In assembly, variables are stored one after another in memory so the last byte of our msg1 variable is right next to the first byte of our msg2 variable.  We know our string length calculation is looking for a zero byte so unless our msg2 variable starts with a zero byte it keeps counting as if it's the same string (and as far as assembly is concerned it is the same string).  So we need to put a zero byte or 0H after our strings to let assembly know where to stop counting.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            In programming 0H denotes a null byte and a null byte after a string tells assembly where it ends in memory.
                        </p> 
                                                
                        <div class="snippet">
                            <span class="filename">helloworld-inc.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (NULL terminating bytes)
                            ; Compile with: nasm -f elf helloworld-inc.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
                            ; Run with: ./helloworld-inc

                            %include        'functions.asm'

                            SECTION .data
                            msg1    db      'Hello, brave new world!', 0AH, 0H          ; NOTE the null terminating byte
                            msg2    db      'This is how we recycle in NASM.', 0AH, 0H  ; NOTE the null terminating byte

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg1        
                                call    sprint          

                                mov     eax, msg2
                                call    sprint

                                call    quit
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-inc.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
                                    <span>~$ ./helloworld-inc</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>
                                                
            </div>
        </div>

        <hr>

        <footer>
            <p>Learn assembly language at <a href="http://asmtutor.com">http://asmtutor.com</a></p>
        </footer>

    </div>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
    <script src="./assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="./assets/script.js"></script>
    
  </body>
</html>

