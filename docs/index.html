<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>NASM Assembly Tutorials - asmtutor.com</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <link href="./assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="./assets/stylesheet.css" rel="stylesheet">
    <link href="./assets/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">

	<script src="./assets/syntax-highlighter/scripts/shCore.js"></script>
	<script src="./assets/syntax-highlighter/scripts/shBrushAsm.js"></script>
	<link href="./assets/syntax-highlighter/styles/shCoreDefault.css" rel="stylesheet">

	<script type="text/javascript">SyntaxHighlighter.all();</script>
    
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">
    <link rel="shortcut icon" href="../assets/ico/favicon.png">
</head>

<body>

    <div class="navbar navbar-inverse navbar-fixed-top">
        <div class="navbar-inner">
            <div class="container-fluid">
                <span class="brand">NASM Assembly Tutorials - asmtutor.com</span>
                <div class="nav-collapse collapse">
                    <p class="navbar-text pull-right">
                        <a class="navbar-link" href="#top">Top</a>
                    </p>
                </div>
            </div>
        </div>
    </div>    

    <div class="container-fluid">
        <div class="row-fluid">
            
            <div class="span3">
                <div class="well span3 sidebar-nav affix">
                    <ul class="nav nav-list">
                        <li class="nav-header">Lessons</li>
                        <li><a href="#lesson1">Lesson 1 <span>Hello, world!</span></a></li>
                        <li><a href="#lesson2">Lesson 2 <span>Proper program exit</span></a></li>
                        <li><a href="#lesson3">Lesson 3 <span>Calculate string length</span></a></li>
                        <li><a href="#lesson4">Lesson 4 <span>Subroutines</span></a></li>
                        <li><a href="#lesson5">Lesson 5 <span>External include files</span></a></li>
                        <li><a href="#lesson6">Lesson 6 <span>NULL terminating bytes</span></a></li>
                        <li><a href="#lesson7">Lesson 7 <span>Linefeeds</span></a></li>
                        <li><a href="#lesson8">Lesson 8 <span>Passing arguments</span></a></li>
                        <li><a href="#lesson9">Lesson 9 <span>User input</span></a></li>
                        <li><a href="#lesson10">Lesson 10 <span>Count to 10</span></a></li>
                        <li><a href="#lesson11">Lesson 11 <span>Count to 10 (itoa)</span></a></li>
                    </ul>
                </div>
            </div>
            
            <div class="span9 lessons">
                
                <div class="hero-unit">
                    <h2>Learn Assembly</h2>
                    <p>This project was put together to teach myself NASM 64bit assembly language on linux. The tutorials are designed to flow on from each other adding functionality at each stage.</p>
                    <p><a href="https://github.com/DGivney/assemblytutorials" class="btn btn-primary btn" target="_blank">Github Project &raquo;</a></p>
                </div>
                  
                <div class="row-fluid">
                    <div class="span4">
                        <h2>Lesson 1</h2>
                        <h5>The obligatory 'Hello, world!'</h5>
                        <p>Introduction to the Linux System Call Table.  In this lesson we use software interrupts to request system functions from the kernel in order to print out 'Hello World!' to the console.</p>
                        <p><a class="btn" href="#lesson1">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 2</h2>
                        <h5>Proper program exit</h5>
                        <p>A very brief lesson about memory addresses, sequential code execution and how to properly terminate a program without errors.</p>
                        <p><a class="btn" href="#lesson2">View details &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 3</h2>
                        <h5>Calculate string length</h5>
                        <p>What if we wanted to output something that we don't know the length of? Like user input? Learn about loops, labels and pointer arithmic.</p>
                        <p><a class="btn" href="#lesson3">View details &raquo;</a></p>
                    </div>
                </div>

                <div class="row-fluid">
                    <div class="span4">
                        <h2>Lesson 4</h2>
                        <h5>Subroutines</h5>
                        <p>Introduction to the stack and how to write clean, reusable code in assembly.</p>
                        <p><a class="btn" href="#lesson4">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 5</h2>
                        <h5>External include files</h5>
                        <p>To further simplify our code we can move our subroutines into an external include file.</p>
                        <p><a class="btn" href="#lesson5">View details &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 6</h2>
                        <h5>NULL terminating bytes</h5>
                        <p>A quick lesson on how memory is handled. This lesson also fixes the duplication bug we added in lesson 5.</p>
                        <p><a class="btn" href="#lesson6">View details &raquo;</a></p>
                    </div>
                </div>

                <div class="row-fluid">
                    <div class="span4">
                        <h2>Lesson 7</h2>
                        <h5>Linefeeds</h5>
                        <p>How you can use the stack to print linefeeds after strings and an introduction to the Extended Stack Pointer ESP.</p>
                        <p><a class="btn" href="#lesson7">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 8</h2>
                        <h5>Passing arguments</h5>
                        <p>Passing arguments to your program from the command line.</p>
                        <p><a class="btn" href="#lesson8">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 9</h2>
                        <h5>User input</h5>
                        <p>Introduction to the BSS section and how to trigger a call to sys_read to process user input.</p>
                        <p><a class="btn" href="#lesson9">View lesson &raquo;</a></p>
                    </div>
                </div>
                
                <div class="row-fluid">
                    <div class="span4">
                        <h2>Lesson 10</h2>
                        <h5>Count to 10</h5>
                        <p>Introduction to numbers and counting in assembly.</p>
                        <p><a class="btn" href="#lesson10">View lesson &raquo;</a></p>
                    </div>
                    <div class="span4">
                        <h2>Lesson 11</h2>
                        <h5>Count to 10 (itoa)</h5>
                        <p>Introduction to ASCII and how to convert integers to their string representations in assembly.</p>
                        <p><a class="btn" href="#lesson11">View lesson &raquo;</a></p>
                    </div>
                </div>
                                          
                <hr>
                
                <div class="row-fluid" id="lesson1">
                    <article class="span12">
                        <header>
                            <h2>Lesson 1</h2>
                            <h4>Hello, world!</h4>
                        </header>

                            <h5>First, some background</h5>

                            <p>Assembly language is bare-bones. The only interface a programmer has above the actual hardware is the kernel itself. In order to build useful programs in assembly we need to use the linux system calls provided by the kernel. These system calls are a library built into the operating system to provide functions such as reading input from a keyboard and writing output to the screen.</p>

                            <p>When you invoke a system call the kernel will immediately suspend execution of your program.  It will then contact the necessary drivers needed to perform the task you requested on the hardware and then return control back to your program.</p>

                            <p>
                                <span class="label label-info">Note:</span>
                                Drivers are called <i>drivers</i> because the kernel literally uses them to drive the hardware.
                            </p>
                        
                            <p>We can accomplish this all in assembly by loading EAX with the function number (operation code OPCODE) we want to execute and filling the remaining registers with the arguments we want to pass to the system call. A software interrupt is requested with the INT instruction and the kernel takes over and calls the function from the library with our arguments. Simple.</p>

                            <p>For example requesting an interrupt when EAX=1 will call sys_exit and requesting an interrupt when EAX=4 will call sys_write instead. EBX, ECX & EDX will be passed as arguments if the function requires them. <a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html" target="_blank">Click here to view an example of a Linux System Call Table and its corresponding OPCODES.</a></p>

                            <h5>Writing our program</h5>

                            <p>Firstly we create a variable 'msg' in our .data section and assign it the string we want to output in this case 'Hello, world!'. In our .text section we tell the kernel where to begin execution by providing it with a global label _start: to denote the programs entry point.</p>

                            <p>We will be using the system call sys_write to output our message to the console window.  This function is assigned OPCODE 4 in the Linux System Call Table.  The function also takes 3 arguments which are sequentially loaded into EDX, ECX and EBX before requesting a software interrupt which will perform the task.</p>

                            <p>The arguments passed are as follows:
                                <ul>
                                    <li> EDX will be loaded with the length (in bytes) of the our string.</li>
                                    <li> ECX will be loaded with the address of our variable created in the .data section.</li>
                                    <li> EBX will be loaded with the file we want to write to – in this case STDOUT.</li>
                                </ul>
                                The datatype and meaning of the arguments passed can be found in the function's definition.
                            </p>

                            <p>We compile, link and run the program using the commands below.</p>

                        <div class="snippet">
                            <span class="filename">helloworld.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program - asmtutor.com
                            ; Compile with: nasm -f elf helloworld.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
                            ; Run with: ./helloworld

                            SECTION .data
                            msg     db      'Hello World!', 0Ah     ; assign msg variable with your message string

                            SECTION .text
                            global  _start

                            _start: 

                                mov     edx, 13     ; number of bytes to write - one for each letter plus 0Ah (line feed character)
                                mov     ecx, msg    ; move the memory address of our message string into ecx
                                mov     ebx, 1      ; write to the STDOUT file
                                mov     eax, 4      ; invoke SYS_WRITE (kernel opcode 4)
                                int     80h
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld.o -o helloworld</span>
                                    <span>~$ ./helloworld</span>
                                    <span>Hello World!</span>
                                    <span>Segmentation fault</span>
                                </div>
                            </div>
                        </div>

                        <p>
                            <span class="label label-important">Error:</span>
                            Segmentation fault
                        </p>
                        
                    </article>
                </div>

                <hr>

                <div class="row-fluid" id="lesson2">
                    <article class="span12">
                        <header>
                            <h2>Lesson 2</h2>
                            <h4>Proper program exit</h4>
                        </header>

                        <h5>Some more background</h5>

                        <p>After successfully learning now to execute a system call in Lesson 1 we now need to learn about one of the most important system calls in the kernel, sys_exit.</p>

                        <p>Notice how after our 'Hello, world!' program ran we got a Segmentation fault? Well, computer programs can be thought of as a long strip of instructions that are loaded into memory and divided up into sections (or segments). This general pool of memory is shared between all programs and can be used to store variables, instructions, other programs or anything really. Each segment is given an address so that information stored in that section can be found later.</p>

                        <p>To execute a program that is loaded in memory, we use the global label _start: to tell the operating system where in memory our program can be found and executed.  Memory is then accessed sequentially following the program logic which determines the next address to be accessed. The kernel jumps to that address in memory and executes it.</p>

                        <p>It's important to tell the operating system exactly where it should begin execution and where it should stop. In Lesson 1 we didn't tell the kernel where to stop execution. So, after we called sys_write the program continued sequentially executing the next address in memory, which could have been anything. We don't know what the kernel tried to execute but it caused it to choke and terminate the process for us instead - leaving us the error message of 'Segmentation fault'.  Calling sys_exit at the end of all our programs will mean the kernel knows exactly when to terminate the process and return memory back to the general pool thus avoiding an error.</p>

                        <h5>Writing our program</h5>

                        <p>Sys_exit has a simple function definition.  In the Linux System Call Table it is allocated OPCODE 1 and is passed a single argument through EBX.</p>

                        <p>In order to execute this function all we need to do is:
                            <ul>
                                <li>Load EBX with 0 to pass zero to the function meaning 'zero errors'.</li>
                                <li>Load EAX with 1 to call sys_exit.</li>
                                <li>Then request an interrupt on libc using INT 80h.</li>
                            </ul>
                        </p>

                        <p>We then compile, link and run it again.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            Only new code added in each lesson will be commented.
                        </p>
                        
                        <div class="snippet">
                            <span class="filename">helloworld.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program - asmtutor.com
                            ; Compile with: nasm -f elf helloworld.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
                            ; Run with: ./helloworld

                            SECTION .data
                            msg     db      'Hello World!', 0Ah

                            SECTION .text
                            global  _start

                            _start: 

                                mov     edx, 13
                                mov     ecx, msg
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0      ; return 0 status on exit - 'No Errors'
                                mov     eax, 1      ; invoke SYS_EXIT (kernel opcode 1)
                                int     80h
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld.o -o helloworld</span>
                                    <span>~$ ./helloworld</span>
                                    <span>Hello World!</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson3">
                    <article class="span12">
                        <header>
                            <h2>Lesson 3</h2>
                            <h4>Calculate string length</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>Why do we need to calculate the length of a string?</p>

                        <p>Well sys_write requires that we pass it a pointer to the string we want to output in memory and the length in bytes we want to print out.  If we were to modify our message string we would have to update the length in bytes that we pass to sys_write as well, otherwise it will not print correctly. </p>

                        <p>You can see what I mean using the program in Lesson 2.  Modify the message string to say 'Hello, brave new world!' then compile, link and run the new program.  The output will be 'Hello, brave ' (the first 13 characters) because we are still only passing 13 bytes to sys_write as its length.  It will be particularly necessary when we want to print out user input.  As we won't know the length of the data when we compile our program, we will need a way to calculate the length at runtime in order to successfully print it out.</p>

                        <h5>Writing our program</h5>

                        <p>To calculate the length of the string we will use a technique called pointer arithmetic.  Two registers are initialised pointing to the same address in memory.  One register (in this case EAX) will be incremented forward one byte for each character in the output string until we reach the end of the string.  The original pointer will then be subtracted from EAX.  This is effectively like subtraction between two arrays and the result yields the number of elements between the two addresses. This result is then passed to sys_write replacing our hard coded count.</p>

                        <p>The CMP instruction compares the left hand side against the right hand side and sets a number of flags that are used for program flow.  The flag we're checking is the ZF or Zero Flag.  When the byte that EAX points to is equal to zero the ZF flag is set.  We then use the JZ instruction to jump, if the ZF flag is set, to the point in our program labeled 'finished'. This is to break out of the nextchar loop and continue executing the rest of the program.</p>
                                                
                        <div class="snippet">
                            <span class="filename">helloworld-len.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Calculating string length)
                            ; Compile with: nasm -f elf helloworld-len.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
                            ; Run with: ./helloworld-len

                            SECTION .data
                            msg     db      'Hello, brave new world!', 0Ah ; we can modify this now without having to update anywhere else in the program

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     ebx, msg        ; move the address of our message string into EBX
                                mov     eax, ebx        ; move the address in EBX into EAX as well (Both now point to the same segment in memory)
                                
                            nextchar:
                                cmp     byte [eax], 0   ; compare the byte pointed to by EAX at this address against zero (Zero is an end of string delimiter)
                                jz      finished        ; jump (if the zero flagged has been set) to the point in the code labeled 'finished'
                                inc     eax             ; increment the address in EAX by one byte (if the zero flagged has NOT been set)
                                jmp     nextchar        ; jump to the point in the code labeled 'nextchar'
                                
                            finished:
                                sub     eax, ebx        ; subtract the address in EBX from the address in EAX
                                                        ; remember both registers started pointing to the same address (see line 15)
                                                        ; but EAX has been incremented one byte for each character in the message string
                                                        ; when you subtract one memory address from another of the same type
                                                        ; the result is number of segments between them - in this case the number of bytes
                                
                                mov     edx, eax        ; EAX now equals the number of bytes in our string
                                mov     ecx, msg        ; the rest of the code should be familiar now
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-len.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
                                    <span>~$ ./helloworld-len</span>
                                    <span>Hello, brave new world!</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>

                <hr>

                <div class="row-fluid" id="lesson4">
                    <article class="span12">
                        <header>
                            <h2>Lesson 4</h2>
                            <h4>Subroutines</h4>
                        </header>

                        <h5>Introduction to subroutines</h5>

                        <p>Subroutines are functions.  They are reusable pieces of code that can be called by your program to perform various repeatable tasks.  Subroutines are declared using labels just like we've used before (eg. _start:) however we don't use the JMP instruction to get to them - instead we use a new instruction <span class="instruction-name">CALL</span>. We also don't use the JMP instruction to return to our program after we have run the function.  To return to our program from a subroutine we use the instruction RET instead.</p>

                        <h5>Why don't we JMP to subroutines?</h5>

                        <p>The great thing about writing a subroutine is that we can reuse it.  If we want to be able to use the subroutine from anywhere in the code we would have to write some logic to determine where in the code we had jumped from and where we should jump back to.  This would litter our code with unwanted labels.  If we use <span class="instruction-name">CALL</span> and RET however, assembly handles this problem for us using something called the stack.</p>

                        <h5>Introduction to the stack</h5>

                        <p>The stack is a special type of memory.  It's the same type of memory that we've used before however it's special in how it is used by our program.  The stack is what is call <strong>Last In First Out</strong> memory (LIFO).  You can think of the stack like a stack of plates in your kitchen.  The last plate you put on the stack is also the first plate you will take off the stack next time you use a plate.</p>

                        <p>The stack in assembly is not storing plates though, its storing values.  You can store a lot of things on the stack such as variables, addresses or other programs.  We need to use the stack when we call subroutines to temporarily store values that will be restored later.</p>

                        <p>Any register that your function needs to use should have it's current value put on the stack for safe keeping using the PUSH instruction.  Then after the function has finished it's logic, these registers can have their original values restored using the POP instruction.  This means that any values in the registers will be the same before and after you've called your function.  If we take care of this in our subroutine we can call functions without worrying about what changes they're making to our registers.</p>

                        <p>The <span class="instruction-name">CALL</span> and RET instructions also use the stack.  When you <span class="instruction-name">CALL</span> a subroutine, the address you called it from in your program is pushed onto the stack.  This address is then popped off the stack by RET and the program jumps back to that place in your code.  This is why you should always JMP to labels but you should <span class="instruction-name">CALL</span> functions.</p>
                                          
                        <div class="snippet">
                            <span class="filename">helloworld-len.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Subroutines)
                            ; Compile with: nasm -f elf helloworld-len.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
                            ; Run with: ./helloworld-len

                            SECTION .data
                            msg     db      'Hello, brave new world!', 0Ah

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg        ; move the address of our message string into EAX
                                call    strlen          ; call our function to calculate the length of the string
                                
                                mov     edx, eax        ; our function leaves the result in EAX
                                mov     ecx, msg        ; this is all the same as before
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h
                                
                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h

                            strlen:                     ; this is our first function declaration
                                push    ebx             ; push the value in EBX onto the stack to preserve it while we use EBX in this function
                                mov     ebx, eax        ; move the address in EAX into EBX (Both point to the same segment in memory)
                                
                            nextchar:                   ; this is the same as lesson3
                                cmp     byte [eax], 0   
                                jz      finished        
                                inc     eax             
                                jmp     nextchar        
                                
                            finished:
                                sub     eax, ebx
                                pop     ebx             ; pop the value on the stack back into EBX
                                ret                     ; return to where the function was called
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-len.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
                                    <span>~$ ./helloworld-len</span>
                                    <span>Hello, brave new world!</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson5">
                    <article class="span12">
                        <header>
                            <h2>Lesson 5</h2>
                            <h4>External include files</h4>
                        </header>

                        <p>External include files allow us to move code from our program and put it into separate files. This technique is useful for writing clean, easy to maintain programs. Reusable bits of code can be written as subroutines and stored in separate files called libraries. When you need a piece of logic you can include the file in your program and use it as if they are part of the same file.</p>

                        <p>In this lesson we will move our string length calculating subroutine into an external file.  We fill also make our string printing logic and program exit logic a subroutine and we will move them into this external file.  Once it's completed our actual program will be clean and easier to read.</p>

                        <p>We can then declare another message variable and call our print function twice in order to demonstrate how we can reuse code.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            I won't be showing the code in functions.asm after this lesson unless it changes. It will just be included if needed.
                        </p>          
                  
                        <div class="snippet">
                            <span class="filename">functions.asm</span>
                            <pre class="brush: asm;">
                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:                     
                                push    ebx             
                                mov     ebx, eax        
                                
                            nextchar:                   
                                cmp     byte [eax], 0   
                                jz      finished        
                                inc     eax             
                                jmp     nextchar        
                                
                            finished:
                                sub     eax, ebx
                                pop     ebx             
                                ret                     


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    edx 
                                push    ecx
                                push    ebx
                                push    eax
                                call    slen
                                
                                mov     edx, eax
                                pop     eax
                                
                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h
                                
                                pop     ebx
                                pop     ecx
                                pop     edx
                                ret


                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h
                                ret


                            </pre>
                        </div>
                        
                        <div class="snippet">
                            <span class="filename">helloworld-inc.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (External file include)
                            ; Compile with: nasm -f elf helloworld-inc.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
                            ; Run with: ./helloworld-inc

                            %include        'functions.asm'                             ; include our external file

                            SECTION .data
                            msg1    db      'Hello, brave new world!', 0Ah              ; our first message string
                            msg2    db      'This is how we recycle in NASM.', 0Ah      ; our second message string

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg1       ; move the address of our first message string into EAX
                                call    sprint          ; call our string printing function
                                
                                mov     eax, msg2       ; move the address of our second message string into EAX
                                call    sprint          ; call our string printing function
                                
                                call    quit            ; call our quit function
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-inc.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
                                    <span>~$ ./helloworld-inc</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                    <span>This is how we recycle in NASM.</span>
                                </div>
                            </div>
                        </div>

                        <p>
                            <span class="label label-important">Error:</span>
                            Our second message is outputted twice.  This is fixed in the next lesson.
                        </p>
                        
                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson6">
                    <article class="span12">
                        <header>
                            <h2>Lesson 6</h2>
                            <h4>NULL terminating bytes</h4>
                        </header>

                        <p>Ok so why did our second message print twice when we only called our sprint function on msg2 once?  Well actually it did only print once.  You can see what I mean if you comment out our second call to sprint.  The output will be both of our message strings.</p>

                        <p>But how is this possible?</p>

                        <p>What is happening is we weren't properly terminating our strings.  In assembly, variables are stored one after another in memory so the last byte of our msg1 variable is right next to the first byte of our msg2 variable.  We know our string length calculation is looking for a zero byte so unless our msg2 variable starts with a zero byte it keeps counting as if it's the same string (and as far as assembly is concerned it is the same string).  So we need to put a zero byte or 0h after our strings to let assembly know where to stop counting.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            In programming 0h denotes a null byte and a null byte after a string tells assembly where it ends in memory.
                        </p> 
                                                
                        <div class="snippet">
                            <span class="filename">helloworld-inc.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (NULL terminating bytes)
                            ; Compile with: nasm -f elf helloworld-inc.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
                            ; Run with: ./helloworld-inc

                            %include        'functions.asm'

                            SECTION .data
                            msg1    db      'Hello, brave new world!', 0Ah, 0h          ; NOTE the null terminating byte
                            msg2    db      'This is how we recycle in NASM.', 0Ah, 0h  ; NOTE the null terminating byte

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg1        
                                call    sprint          

                                mov     eax, msg2
                                call    sprint

                                call    quit
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-inc.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
                                    <span>~$ ./helloworld-inc</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                </div>
                            </div>
                        </div>

                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson7">
                    <article class="span12">
                        <header>
                            <h2>Lesson 7</h2>
                            <h4>Linefeeds</h4>
                        </header>

                        <p>Linefeeds are essential to console programs like our 'hello world' program.  They become even more important once we start building programs that require user input. But linefeeds can be a pain to maintain.  Sometimes you will want to include them in your strings and sometimes you will want to remove them.  If we continue to hard code them in our variables by adding 0Ah after our declared message text, it will become a problem.  If there's a place in the code that we don't want to print out the linefeed for that variable we will need to write some extra logic remove it from the string at runtime.</p>

                        <p>It would be better for the maintainability of our program if we write a subroutine that will print out our message and then print a linefeed afterwards. That way we can just call this subroutine when we need the linefeed and call our current sprint subroutine when we don't.</p>

                        <p>A call to sys_write requires we pass a pointer to an address in memory of the string we want to print so we can't just pass a linefeed character (0Ah) to our print function.  We also don't want to create another variable just to hold a linefeed character so we will instead use the stack.</p>

                        <p>The way it works is by moving a linefeed character into EAX.  We then push EAX onto the stack and get the address pointed to by the Extended Stack Pointer.  ESP is another register.  When you push items onto the stack, ESP is decremented to point to the address in memory of the last item and so it can be used to access that item directly from the stack. Since ESP points to an address in memory of a character, sys_write will be able to use it to print.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            I've highlighted the new code in functions.asm below.
                        </p>
                        
                        <div class="snippet">
                            <span class="filename">functions.asm</span>
                            <pre class="brush: asm;  highlight: [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]">
                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:                     
                                push    ebx             
                                mov     ebx, eax        
                                
                            nextchar:                   
                                cmp     byte [eax], 0   
                                jz      finished        
                                inc     eax             
                                jmp     nextchar        
                                
                            finished:
                                sub     eax, ebx
                                pop     ebx             
                                ret                     


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    edx
                                push    ecx
                                push    ebx
                                push    eax
                                call    slen
                                
                                mov     edx, eax
                                pop     eax
                                
                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h
                                
                                pop     ebx
                                pop     ecx
                                pop     edx
                                ret


                            ;------------------------------------------
                            ; void sprintLF(String message)
                            ; String printing with line feed function
                            sprintLF:
                                call    sprint

                                push    eax         ; push eax onto the stack to preserve it while we use the eax register in this function
                                mov     eax, 0Ah    ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
                                push    eax         ; push the linefeed onto the stack so we can get the address
                                mov     eax, esp    ; move the address of the current stack pointer into eax for sprint
                                call    sprint      ; call our sprint function
                                pop     eax         ; remove our linefeed character from the stack
                                pop     eax         ; restore the original value of eax before our function was called
                                ret                 ; return to our program

                                
                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h
                                ret


                            </pre>
                        </div>
                                                
                        <div class="snippet">
                            <span class="filename">helloworld-lf.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Print with line feed)
                            ; Compile with: nasm -f elf helloworld-lf.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-lf.o -o helloworld-lf
                            ; Run with: ./helloworld-lf

                            %include        'functions.asm'

                            SECTION .data
                            msg1    db      'Hello, brave new world!', 0h          ; NOTE we have removed the line feed character 0Ah
                            msg2    db      'This is how we recycle in NASM.', 0h  ; NOTE we have removed the line feed character 0Ah

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg1        
                                call    sprintLF    ; NOTE we are calling our new print with linefeed function

                                mov     eax, msg2
                                call    sprintLF    ; NOTE we are calling our new print with linefeed function

                                call    quit
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-lf.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-lf.o -o helloworld-lf</span>
                                    <span>~$ ./helloworld-lf</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                </div>
                            </div>
                        </div>
                        
                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson8">
                    <article class="span12">
                        <header>
                            <h2>Lesson 8</h2>
                            <h4>Passing arguments</h4>
                        </header>

                        <p>Passing arguments to your program from the command line is as easy as popping them off the stack in NASM. When we run our program, any passed arguments are loaded onto the stack in reverse order.  The name of the program is then loaded onto the stack and lastly the total number of arguments is loaded onto the stack. The last two stack items for a NASM compiled program are always the name of the program and the number of passed arguments.</p>

                        <p>So all we have to do to use them is pop the number of arguments off the stack first, then iterate once for each argument and perform our logic. In our program that means calling our print function.</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            We are using the ECX register as our counter for the loop. Although it's a general-purpose register it's original intention was to be used as a counter.
                        </p>
                                                                        
                        <div class="snippet">
                            <span class="filename">helloworld-args.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Passing arguments from the command line)
                            ; Compile with: nasm -f elf helloworld-args.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-args.o -o helloworld-args
                            ; Run with: ./helloworld-args

                            %include        'functions.asm'

                            SECTION .text
                            global  _start
                                
                            _start: 

                                pop     ecx             ; first value on the stack is the number of arguments
                                
                            nextArg:
                                cmp     ecx, 0h         ; check to see if we have any arguments left
                                jz      noMoreArgs      ; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)
                                pop     eax             ; pop the next argument off the stack
                                call    sprintLF        ; call our print with linefeed function
                                dec		ecx             ; decrease ecx (number of arguments left) by 1
                                jmp     nextArg         ; jump to nextArg label
                                
                            noMoreArgs:   
                                call    quit
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-args.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-lf.o -o helloworld-args</span>
                                    <span>~$ ./helloworld-args "This is one argument" "This is another" 101</span>
                                    <span>./helloworld-args</span>
                                    <span>This is one argument</span>
                                    <span>This is another</span>
                                    <span>101</span>
                                </div>
                            </div>
                        </div>
                        
                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson9">
                    <article class="span12">
                        <header>
                            <h2>Lesson 9</h2>
                            <h4>User input</h4>
                        </header>

                        <h5>Introduction to the .bss section</h5>

                        <p>So far we've used the .text and .data section so now it's time to introduce the .bss section. BSS stands for Block Started by Symbol.  It is an area in our program that is used to reserve space in memory for uninitialised variables. We will use it to reserve some space in memory to hold our user input since we don't know how many bytes we'll need to store.</p>

                        <p>The syntax to declare variables is as follows:</p>

                        <div class="snippet">
                            <span class="filename">.bss section example</span>
                            <pre class="brush: asm;">
                            SECTION .bss
                            variableName1:      RESB    1       ; reserve space for 1 byte
                            variableName2:      RESW    1       ; reserve space for 1 word
                            variableName3:      RESD    1       ; reserve space for 1 double word
                            variableName4:      RESQ    1       ; reserve space for 1 double precision float (quad word)
                            variableName5:      REST    1       ; reserve space for 1 extended precision float
                            </pre>
                        </div>
                        
                        <h5>Writing our program</h5>

                        <p>We will be using the system call sys_read to receive and process input from the user. This function is assigned OPCODE 3 in the Linux System Call Table. Just like sys_write this function also takes 3 arguments which will be loaded into EDX, ECX and EBX before requesting a software interrupt that will call the function.</p>

                        <p>The arguments passed are as follows:
                            <ul>
                                <li> EDX will be loaded with the maximum length (in bytes) of the our space in memory.</li>
                                <li> ECX will be loaded with the address of our variable created in the .bss section.</li>
                                <li> EBX will be loaded with the file we want to write to – in this case STDIN.</li>
                            </ul>
                            As always the datatype and meaning of the arguments passed can be found in the function's definition.
                        </p>

                        <p>When sys_read detects a linefeed, control returns to the program and the users input is located at the memory address you passed in ECX.</p>

                        <div class="snippet">
                            <span class="filename">helloworld-input.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Getting input)
                            ; Compile with: nasm -f elf helloworld-input.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-input.o -o helloworld-input
                            ; Run with: ./helloworld-input

                            %include        'functions.asm'

                            SECTION .data
                            msg1        db      'Please enter your name: ', 0h      ; message string asking user for input
                            msg2        db      'Hello, ', 0h                       ; message string to use after user has entered their name

                            SECTION .bss
                            sinput:     resb    255                                 ; reserve a 255 byte space in memory for the users input string
                                
                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     eax, msg1       
                                call    sprint

                                mov     edx, 255        ; number of bytes to read
                                mov     ecx, sinput     ; reserved space to store our input (known as a buffer)
                                mov     ebx, 0          ; write to the STDIN file
                                mov     eax, 3          ; invoke SYS_READ (kernel opcode 3)
                                int     80h

                                mov     eax, msg2       
                                call    sprint

                                mov     eax, sinput     ; move our buffer into eax (Note: input contains a linefeed)
                                call    sprint          ; call our print function
                                
                                call    quit                                           
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-input.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-input.o -o helloworld-input</span>
                                    <span>~$ ./helloworld-input</span>
                                    <span>Please enter your name: Daniel Givney</span>
                                    <span>Hello, Daniel Givney</span>
                                </div>
                            </div>
                        </div>
                        
                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson10">
                    <article class="span12">
                        <header>
                            <h2>Lesson 10</h2>
                            <h4>Count to 10</h4>
                        </header>

                        <h5>Firstly, some background</h5>
                        
                        <p>Counting by numbers is not as straight forward as you would think in assembly.  Firstly we need to pass sys_write an address in memory so we can't just load our register with a number and call our print function.  Secondly, numbers and strings are very different things in assembly.  Strings are represented by what are called ASCII values.  ASCII stands for <strong>American Standard Code for Information Interchange</strong>.  A good reference for ASCII <a href=”http://www.asciitable.com/”>can be found here</a>. ASCII was created as a way to standardise the representation of strings across all computers.</p>

                        <p>Remember, we can't print a number - we have to print a string. In order to count to 10 we will need to convert our numbers from standard integers to their ASCII string representations.  Have a look at the ASCII values table and notice that the string representation for the number '1' is actually '49' in ASCII. In fact, adding 48 to our numbers is all we have to do to convert them from integers to their ASCII string representations.</p>

                        <h5>Writing our program</h5>

                        <p>What we will do with our program is count from 1 to 10 using the ECX register.  We will then add 48 to our counter to convert it from a number to it's ASCII string representation.  We will then push this value to the stack and call our print function passing ESP as the memory address to print from.  Once we have finished counting to 10 we will exit our counting loop and call our quit function.</p>

                        <div class="snippet">
                            <span class="filename">helloworld-10.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Count to 10)
                            ; Compile with: nasm -f elf helloworld-10.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-10.o -o helloworld-10
                            ; Run with: ./helloworld-10

                            %include        'functions.asm'

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     ecx, 0          ; ecx is initalised to zero.
                                
                            nextNumber:
                                inc     ecx             ; increment ecx
                                
                                mov     eax, ecx        ; move the address of our integer into eax
                                add     eax, 48         ; add 48 to our number to convert from integer to ascii for printing
                                push    eax             ; push eax to the stack
                                mov     eax, esp        ; get the address of the character on the stack
                                call    sprintLF        ; call our print function
                                
                                pop     eax             ; clean up the stack so we don't have unneeded bytes taking up space
                                cmp     ecx, 10         ; have we reached 10 yet? compare our counter with decimal 10
                                jne     nextNumber      ; jump if not equal and keep counting
                                  
                                call    quit                                        
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-10.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-10.o -o helloworld-10</span>
                                    <span>~$ ./helloworld-10</span>
                                    <span>1</span>
                                    <span>2</span>
                                    <span>3</span>
                                    <span>4</span>
                                    <span>5</span>
                                    <span>6</span>
                                    <span>7</span>
                                    <span>8</span>
                                    <span>9</span>
                                    <span>:</span>
                                </div>
                            </div>
                        </div>

                        <p>
                            <span class="label label-important">Error:</span>
                            Our number 10 prints a colon (:) character instead.  What's going on?
                        </p>
                        
                    </article>
                </div>
                
                <hr>

                <div class="row-fluid" id="lesson11">
                    <article class="span12">
                        <header>
                            <h2>Lesson 11</h2>
                            <h4>Count to 10 (itoa)</h4>
                        </header>

                        <p>So why did our program in Lesson 10 print out a colon character instead of the number 10?.  Well lets have a look at our ASCII table.  We can see that the colon character has a ASCII value of 58.  We were adding 48 to our integers to convert them to their ASCII string representations so instead of passing sys_write the value '58' to print ten we actually need to pass the ASCII value for the number 1 followed by the ASCII value for the number 0. Passing sys_write '4948' is the correct string representation for the number '10'. So we can't just simply add 48 to our numbers to convert them, we first have to divide them by 10 because each place value needs to be converted individually.</p>

                        <p>We will write 2 new subroutines in this lesson 'iprint' and 'iprintLF'.  These functions will be used when we want to print ASCII string representations of numbers.  We achieve this by passing the number in EAX.  We then initialise a counter in ECX.  We will repeatedly divide the number by 10 and each time convert the remainder to a string by adding 48.  We will then push this onto the stack for later use. Once we can no longer divide the number by 10 we will enter our second loop.  In this print loop we will print the now converted string representations from the stack and pop them off.  Popping them off the stack moves ESP forward to the next item on the stack. Each time we print a value we will decrease our counter ECX.  Once all numbers have been converted and printed we will return to our program.</p>

                        <h5>How does the divide instruction work?</h5>

                        <p>The DIV and IDIV instructions work by dividing whatever is in EAX by the value passed to the instruction.  The quotient part of the value is left in EAX and the remainder part is put into EDX (Originally called the data register).
                        
                        <p>For example.</p>

                        <div class="snippet">
                            <span class="filename">IDIV instruction example</span>
                            <pre class="brush: asm;">
                            mov     eax, 10         ; move 10 into eax
                            mov     esi, 10         ; move 10 into esi
                            idiv    esi             ; divide eax by esi (eax will equal 1 and edx will equal 0)
                            idiv    esi             ; divide eax by esi again (eax will equal 0 and edx will equal 1)
                            </pre>
                        </div>

                        <h5>If we are only storing the remainder won't we have problems?</h5>

                        <p>No, because these are integers, when you divide a number by an even bigger number the quotient in EAX is 0 and the remainder is the number itself. This is because the number divides zero times leaving the original value as the remainder in EDX. How good is that?</p>

                        <p>
                            <span class="label label-info">Note:</span>
                            Only the new functions iprint and iprintLF have comments.
                        </p>
                        
                        <div class="snippet">
                            <span class="filename">functions.asm</span>
                            <pre class="brush: asm;">
                            ;------------------------------------------
                            ; void iprint(Integer number)
                            ; Integer printing function (itoa)
                            iprint:
                                push    eax             ; preserve eax on the stack to be restored after function runs
                                push    ecx             ; preserve ecx on the stack to be restored after function runs
                                push    edx             ; preserve edx on the stack to be restored after function runs
                                push    esi             ; preserve esi on the stack to be restored after function runs
                                mov     ecx, 0          ; counter of how many bytes we need to print in the end
                                
                            divideLoop:
                                inc     ecx             ; count each byte to print - number of characters
                                mov     edx, 0          ; empty edx
                                mov     esi, 10         ; mov 10 into esi
                                idiv    esi             ; divide eax by esi
                                add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction
                                push    edx             ; push edx (string representation of an intger) onto the stack
                                cmp     eax, 0          ; can the integer be divided anymore?
                                jnz     divideLoop      ; jump if not zero to the label divideLoop

                            printLoop:
                                dec     ecx             ; count down each byte that we put on the stack
                                mov     eax, esp        ; mov the stack pointer into eax for printing
                                call    sprint          ; call our string print function
                                pop     eax             ; remove last character from the stack to move esp forward
                                cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?
                                jnz     printLoop       ; jump is not zero to the label printLoop

                                pop     esi             ; restore esi from the value we pushed onto the stack at the start
                                pop     edx             ; restore edx from the value we pushed onto the stack at the start
                                pop     ecx             ; restore ecx from the value we pushed onto the stack at the start
                                pop     eax             ; restore eax from the value we pushed onto the stack at the start
                                ret


                            ;------------------------------------------
                            ; void iprintLF(Integer number)
                            ; Integer printing function with linefeed (itoa)
                            iprintLF:
                                call    iprint          ; call our integer printing function

                                push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function
                                mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
                                push    eax             ; push the linefeed onto the stack so we can get the address
                                mov     eax, esp        ; move the address of the current stack pointer into eax for sprint
                                call    sprint          ; call our sprint function
                                pop     eax             ; remove our linefeed character from the stack
                                pop     eax             ; restore the original value of eax before our function was called
                                ret

                                
                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:                     
                                push    ebx             
                                mov     ebx, eax        
                                
                            nextchar:                   
                                cmp     byte [eax], 0   
                                jz      finished        
                                inc     eax             
                                jmp     nextchar        
                                
                            finished:
                                sub     eax, ebx
                                pop     ebx             
                                ret                     


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    edx
                                push    ecx
                                push    ebx
                                push    eax
                                call    slen
                                
                                mov     edx, eax
                                pop     eax
                                
                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                pop     ebx
                                pop     ecx
                                pop     edx
                                ret


                            ;------------------------------------------
                            ; void sprintLF(String message)
                            ; String printing with line feed function
                            sprintLF:
                                call    sprint

                                push    eax
                                mov     eax, 0AH
                                push    eax
                                mov     eax, esp
                                call    sprint
                                pop     eax
                                pop     eax
                                ret

                                
                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0      
                                mov     eax, 1      
                                int     80h
                                ret

                               
                            </pre>
                        </div>

                        <div class="snippet">
                            <span class="filename">helloworld-itoa.asm</span>
                            <pre class="brush: asm;">
                            ; Hello World Program (Count to 10 itoa)
                            ; Compile with: nasm -f elf helloworld-itoa.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa
                            ; Run with: ./helloworld-itoa

                            %include        'functions.asm'

                            SECTION .text
                            global  _start
                                
                            _start: 

                                mov     ecx, 0
                                
                            nextNumber:
                                inc     ecx
                                mov     eax, ecx
                                call    iprintLF        ; NOTE call our new integer printing function (itoa)
                                cmp     ecx, 10
                                jne     nextNumber
                                  
                                call    quit                                    
                            </pre>
                            <div class="output">
                                <div class="inner">
                                    <span>~$ nasm -f elf helloworld-itoa.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa</span>
                                    <span>~$ ./helloworld-itoa</span>
                                    <span>1</span>
                                    <span>2</span>
                                    <span>3</span>
                                    <span>4</span>
                                    <span>5</span>
                                    <span>6</span>
                                    <span>7</span>
                                    <span>8</span>
                                    <span>9</span>
                                    <span>10</span>
                                </div>
                            </div>
                        </div>
                        
                    </article>
                </div>
                                                
            </div>
        </div>

        <hr>

        <footer>
            <p>Learn assembly language at <a href="http://asmtutor.com">http://asmtutor.com</a></p>
        </footer>

    </div>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
    <script src="./assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="./assets/script.js"></script>
    
  </body>
</html>

